[ { "title": "Marshalling vs Serialization", "url": "/posts/marshalling-and-serialization/", "categories": "Java, Theory", "tags": "writing", "date": "2022-08-17 08:20:00 +0900", "snippet": "Mashalling vs SerializationMashalling설명 Wikipedia한 객체의 메모리에서 표현방식을 저장 또는 전송에 적합한 다른 데이터 형식으로 변환하는 과정이다.또한 이는 데이터를 컴퓨터 프로그램의 서로 다른 부분 간에 혹은 한 프로그램에서 다른 프로그램으로 이동해야 할 때도 사용된다.마셜링은 직렬화(serialization)와 유사하며 한 오브젝트(여기서는 직렬화 된 오브젝트)로 멀리 떨어진 오브젝트와 통신하기 위해 사용된다Serialization설명 Wikipedia 직렬화(serialization)는 컴퓨터 과학의 데이터 스토리지 문맥에서 데이터 구조나 오브젝트 상태를 동일하거나 다른 컴퓨터 환경에 저장(이를테면 파일이나 메모리 버퍼에서, 또는 네트워크 연결 링크 간 전송)하고 나중에 재구성할 수 있는 포맷으로 변환하는 과정이다. 오브젝트를 직렬화하는 과정은 오브젝트를 마샬링한다고도 한다. 반대로, 일련의 바이트로부터 데이터 구조를 추출하는 일은 역직렬화(deserialization)이라고 한다.Serialization은 객체 전송을 위해서 Byte Stream 으로 변환하여 파일 또는 네트워크를 통해 스트림이 가능하도록 하게 하는 것Mashalling은 바이트 스트림에 보낼 수 있는 객체로 변환하는 작업을 뜻함참고https://weicomes.tistory.com/63https://lueseypid.tistory.com/42" }, { "title": "Frame과 Bounds 차이", "url": "/posts/frame-diff-bounds/", "categories": "ios, view", "tags": "writing", "date": "2022-07-08 08:56:00 +0900", "snippet": "Frame vs BoundsFrame The frame rectangle, which describes the view’s location and size in its superview’s coordinate system. Superview의 좌표계에서 위치와 크기Bounds The bounds rectangle, which describes the view’s location and size in its own coordinate system. 자신만의 좌표계에서 위치와 크기정리 중TODO: 예제 정리 중" }, { "title": "Jekyll 블로깅을 쉽게하기 위한 Template 만들기", "url": "/posts/webstorm-template/", "categories": "Blogging, Template", "tags": "webstorm, template", "date": "2022-05-10 08:37:00 +0900", "snippet": "Jekyll Custom Markdown Template 만들기Jekyll Custom Markdown Template(Jetbrains 제품 기준) 매일 파일 만들기가 불편하여 오늘 갑자기 Custom Template을 만들고 싶어서 블로깅 블로깅.. Eclipse 쓸 때, Custom Template 만들어서 썼던 기억이 있어서 검색해서 만들어 보았어요 자 지금 시작합니다1. IntelliJ 혹은 Webstorm (저는 Webstorm) 실행2. Mac : Cmd + Shift + A, Windows : Ctrl + Shift + A -&gt; action 검색창3. 'file template' 검색 &lt;br&gt;4. file template 선택 &lt;br&gt;5. '+' (create template) 후, 하기 이미지처럼 작성 그 외 변수는 사이트 참고 제목, 소제목, 본문 등으로 정리하면 좋을 것 같다" }, { "title": "Spring Batch + Quartz 2편", "url": "/posts/spring-quartz/", "categories": "Develop, Spring Batch+Quartz", "tags": "writing", "date": "2022-03-22 09:46:00 +0900", "snippet": "간단한 Spring Batch 설명을 마치고 Quartz 설명을 시작하도록 하겠습니다.목차 Quartz란? Quartz 구조 Quartz 설정 Quartz 적용 Quartz 실행 마치며 참고자료 1. Quartz란? Quartz는 Terracotta라는 회사에 의해 개발된 Job Scheduling 라이브러리 DB기반으로(In-memory 환경에서 안됨) 스케줄러 Clustering 기능 제공 In-memory Job Scheduler도 제공2. Quartz 구조 Quartz Architect Image Job : Scheduling 할 실제 작업을 구현한 객체 JobFactory : Job을 인스턴스화 시키는 클래스 JobDetail : Job을 실행시키기 위한 정보를 담고 있는 객체. Trigger가 JobDetail을 기반으로 스케줄링 JobDataMap : Job이 execute함수를 실행할 때 사용할 수 있게 원하는 정보를 담을 수 있는 객체 JobStore : Scheduler에 등록된 Job, Trigger, 실행이력 등이 저장되는 공간. type에 따라 memory 또는 jdbc에 저장 Trigger : Job을 실행시킬 스케줄링 조건. 한 개 이상의 Trigger는 반드시 하나의 Job을 지정할 수 있다.Trigger의 종류로는 SimpleTrigger(ex) .withIntervalInSeconds(10 - 매 10초마다 실행), CronTrigger(ex) .setCronExpression(\"0 */1 * * * ?\") - 매 1분마다 실행)가 존재 Scheduler : JobDetail과 Trigger의 등록을 유지하고 관리하고 등록된 Job의 실행을 담당 SchedulerFactory : Scheduler 인스턴스를 생성하는 매커니즘3. Quartz 설정application.yml 설정과 JavaConfig로 설정하는 방법에 대해 설명하도록 하겠습니다. 메타테이블 설명 : https://developyo.tistory.com/252 참고 메타테이블 SQL : https://github.com/quartz-scheduler/quartz/tree/master/quartz-core/src/main/resources/org/quartz/impl/jdbcjobstore 참고 application.yml : 기존의 jdbc 설정이 있다면 datasource 내용은 skip 하셔도 됩니다.#==============================================================================## Configure Quartz ##==============================================================================#spring: datasource: url: jdbc:mariadb://localhost:3306/quartz username: quartz_admin password: 1q2w3e4r hikari: driver-class-name: org.mariadb.jdbc.Driver maximum-pool-size: 50 connection-test-query: SELECT 1 connection-timeout: 30000 idle-timeout: 30000 minimum-idle: 5 batch: job: enabled: false quartz: scheduler-name: testScheduler job-store-type: jdbc overwrite-existing-jobs: true jdbc: initialize-schema:neverorg: quartz: scheduler: instanceId: AUTO instanceName: testScheduler-1.0 makeSchedulerThreadDaemon: true interruptJobsOnShutdown: true jobStore: class: org.quartz.impl.jdbcjobstore.JobStoreTX driverDelegateClass: org.quartz.impl.jdbcjobstore.StdJDBCDelegate useProperties: false tablePrefix: QRTZ_ isClustered: true clusterCheckinInterval: 20000 threadPool: class: org.quartz.simpl.SimpleThreadPool threadCount: 10 threadPriority: 5 threadsInheritContextClassLoaderOfInitializingThread: true QuartzConfig.java@Slf4j@Configurationpublic class QuartzConfig { // JobRegistry 자동 등록 @Bean public JobRegistryBeanPostProcessor jobRegistryBeanPostProcessor(JobRegistry jobRegistry) { JobRegistryBeanPostProcessor jobRegistryBeanPostProcessor = new JobRegistryBeanPostProcessor(); jobRegistryBeanPostProcessor.setJobRegistry(jobRegistry); return jobRegistryBeanPostProcessor; }\t // Quartz Scheduler 설정 @Bean public SchedulerFactoryBean schedulerFactoryBean(DataSource dataSource, QuartzProperties quartzProperties) throws Exception { SchedulerFactoryBean schedulerFactoryBean = new SchedulerFactoryBean(); schedulerFactoryBean.setDataSource(dataSource); // jdbc 설정 schedulerFactoryBean.setQuartzProperties(quartzProperties()); // quartz 설정 적용 schedulerFactoryBean.setWaitForJobsToCompleteOnShutdown(true); // job 완료 시 shutdown 설정 schedulerFactoryBean.setOverwriteExistingJobs(true); return schedulerFactoryBean; } // Properties를 application.yml에서 읽어옴 @Bean public Properties quartzProperties() throws IOException { PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean(); propertiesFactoryBean.setLocation(new ClassPathResource(\"/application.yml\")); propertiesFactoryBean.afterPropertiesSet(); return propertiesFactoryBean.getObject(); }}4. Quartz 적용기존 등록했던 Spring Batc에 Quartz의 JobDetail, Trigger만 Configuration 해주면 된다 BatchConfig.java@Configuration@RequiredArgsConstructor@EnableBatchProcessing // 배치 기능 활성화 -&gt; @SpringBootApplication이 선언되어 있는 곳에 해줘도 됩니다. 테스트 코드라 작성하였습니다.public class BatchConfig { private final JobBuilderFactory jobBuilderFactory; private final StepBuilderFactory stepBuilderFactory;\t // Step Configuration @Bean @JobScope public Step stepOne() { return stepBuilderFactory.get(\"stepOne\") .allowStartIfComplete(true) .tasklet(new TaskTasklet()) .build(); } @Bean @JobScope public Step stepTwo() { return stepBuilderFactory.get(\"stepTwo\") .tasklet(new TaskTwo()) .allowStartIfComplete(true) .build(); }\t // Job Configuration @Bean public Job setTestJob() throws Exception { return jobBuilderFactory.get(\"testJob\") .incrementer(new RunIdIncrementer()) .start(stepOne()) // 하위 실행 할 tasklet을 더 구성했다면 .next(new 새로운Tasklet())로 추가해주시면 됩니다. .build(); } // JobDetail Configuration @Bean(name = \"quartzJobTest\") public JobDetailFactoryBean setQuartzJobTest() { JobDetailFactoryBean jobDetailFactoryBean = new JobDetailFactoryBean(); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"job\", demoJobOne().getName()); jobDetailFactoryBean.setDurability(true); // 지속성 jobDetailFactoryBean.setJobClass(CustomQuartzJob.class); jobDetailFactoryBean.setRequestsRecovery(true); // 리커버리 jobDetailFactoryBean.setJobDataAsMap(map); return jobDetailFactoryBean; } // Trigger Configuration @Bean public CronTriggerFactoryBean setQuartzTriggerTest() { CronTriggerFactoryBean cronTriggerFactoryBean = new CronTriggerFactoryBean(); cronTriggerFactoryBean.setName(\"quartzTriggerTest\"); cronTriggerFactoryBean.setJobDetail(setQuartzJobTest().getObject()); cronTriggerFactoryBean.setCronExpression(\"0 */1 * * * ?\"); // cron expression settings return cronTriggerFactoryBean; }} CustomQuartzJob.java@Slf4j@PersistJobDataAfterExecution // Job 로직에서 JobDataMap 데이터를 수정하면 실행이후에 DB에 저장이 안됩니다. 해당 어노테이션 사용 시, JobDataMap을 수정한 데이터를 다음 실행 때에도 반영된 데이터를 읽을 수 있습니다.@DisallowConcurrentExecution // Job 동시실행 방지 어노테이션public class CustomQuartzJob implements Job { @Autowired private JobLauncher jobLauncher; @Autowired private JobLocator jobLocator; @Override public void execute(JobExecutionContext context) throws JobExecutionException { try { JobDataMap jobDataMap = context.getMergedJobDataMap(); String jobName = jobDataMap.get(\"job\").toString(); log.info(\"jobDataMap : {}\", jobDataMap); log.info(\"start\"); jobLauncher.run(jobLocator.getJob(jobName), new JobParameters()); log.info(\"end\"); } catch (Exception e) { log.error(\"batch error\"); } }}5. Quartz 실행 어플리케이션 실행 화면 : 쿼츠가 동작한 후 Job이 정상적으로 실행되었습니다. 어플리케이션 실행 후, QRTZ_SCHEDULER_STATE(Scheduler), QRTZ_JOB_DETAILS(JobDetail), QRTZ_TRIGGERS(Trigger), QRTZ_CRON_TRIGGER(Trigger Cron) 메타테이블에 등록되었고, 해당 Job 실행 후 Spring Batch 메타 테이블에도 실행이력이 저장됩니다. 클러스터링 테스트 : 동일 프로젝트 복제 후, 다른 포트로 실행 → QRTZ_SCHEDULER_STATE 테이블의 SCHED_NAME과 INSTANCE_NAME으로 동일 스케줄러의 다른 인스턴스를 구별 실행화면 QRTZ_SCHEULER_STATE Table : 스케줄러가 다른 InstanceName으로 구별되어 있음.만약, 스케줄러 하나가 종료되면 LAST_CHECKIN_TIME과 CHECKIN_INTERVAL로 비교해서 스케줄러가 종료 됐는지 확인 후 업데이트 두개 같은 스케줄러 동작 InstanceName (…)1647055337368 스케줄러 종료 시, interval 지난 후 자동으로 업데이트되고 다른 인스턴스에서 정상적으로 Job이 실행되는 것을 볼 수 있다.(failover 기능) 클러스터링 시, CustomQuartzJob.java의 @DisallowConcurrentExecution 어노테이션에 의해서 서로의 Job이 동시에 실행되지 않고 랜덤하게 분산되어 실행된다.6. 마치며Spring Batch + Quartz 를 적용하면서, 많은 블로그와 공식 문서를 보면서 작성하였는데 제 생각에 ‘이렇게 하면 될 것 같다’ 작성한 것이기 때문에 잘못된 정보가 있을 수 있으므로 피드백 부탁드립니다 ^^회사 소스 코드를 인용할 수 없어 테스트 코드를 이용하여 너무 간단한 설명이 된 것 같네요아무튼 한번 구성해보시면 좋을 것 같습니다.블로그 봐주셔서 감사합니다.7. 참고자료Quartz - Documentationadvenoh bloghttps://kouzie.github.io/spring/Spring-Boot-스프링-부트-Quartz/#https://examples.javacodegeeks.com/enterprise-java/spring/batch/quartz-spring-batch-example/" }, { "title": "Spring Batch + Quartz 1편", "url": "/posts/spring-batch/", "categories": "Develop, Spring Batch+Quartz", "tags": "writing", "date": "2022-03-21 09:46:00 +0900", "snippet": "이번에 Spring Batch와 Quartz를 주제로 공유드리고자 합니다.Spring Batch만 사용하였다가 Quartz의 Clustering 기능이 필요하게 되어 두개의 기술을한 페이지에 구성하려니 스크롤 내리는게 귀찮으실 것 같아 Spring Batch를 1편에 Quartz를 2편으로 구성하였습니다.두개의 블로그 중에 필요한 블로그를 참고해주시면 좋을 것 같습니다.자 그럼 시작하겠습니다!!목차 Spring Batch란? Spring Batch 설명 Spring Batch 적용 마치며 참고자료 1. Spring Batch란? 일반적으로 배치란 일괄처리(한꺼번에 처리)를 의미 로깅/추적, 트랜잭션 관리, job 프로세싱 통계, job 재시작, 스킵, 리소스 관리 같은 대용량 데이터 처리에 필수적인 기능을 재사용할 수 있는 형태로 제공2. Spring Batch 설명 Batch Architect Image Job : 전체 배치 프로세스를 캡슐화한 엔티티 JobInstance : Job의 실행 단위. Job 실행 시, 하나의 JobInstance가 생성 JobParameters : JobParameters의 객체로 JobInstance를 구별. 그리고 JobInstance에 전달되는 매개변수 역할. Type은 String, Double, Long, Date 만 지원 JobExecution : JobInstance에 대한 실행 시도에 대한 객체. JobInstance에 대한 상태, 시작시간, 종료시간, 생성시간 등의 정보 Step : Job의 배치처리를 정의, 순차적 단계를 캡슐화. Job은 최소 1개 이상의 Step을 가져야 함 StepExecution : Step 실행 시도에 대한 객체 JobLauncher : Job과 JobParameters를 사용하여 Job을 실행하는 객체3. Spring Batch 적용Job과 Step에 중점을 두고 적용하는 법에 대해 간단한 예제 코드로 설명드리겠습니다.메타테이블 설정은 https://docs.spring.io/spring-batch/docs/current/reference/html/schema-appendix.html 참고하시면 됩니다.a. Step 구성Step 구성은 Tasklet으로 구성하여 등록하였습니다.Tasklet이란 Step안에서 수행될 비즈니스 로직 전략의 인터페이스라고 합니다.Tasklet으로 간단하게 execute에 로직만 구현하면 되므로 쉬운 구성이 가능합니다.만약 대용량 데이터를 많이 다룬다하면 Reader - Processor - Writer 를 이용한 Chunk Oriented Processing을 권장합니다. Tasklet 구성public class TestTasklet implements Tasklet {\t\t@Override public RepeatStatus execute(StepContribution stepContribution, ChunkContext chunkContext) throws Exception { // 비지니스 로직이 들어갈 부분 return RepeatStatus.FINISHED; }} Step 구성@Beanpublic Step stepOne() { return stepBuilderFactory.get(\"stepOne\") .tasklet(new TaskTasklet()) .build();}b. Job 구성구현한 Step을 실행할 Job을 등록합니다.@Beanpublic Job setTestJob() throws Exception {\treturn jobBuilderFactory.get(\"testJob\")\t\t\t\t\t.incrementer(new RunIdIncrementer())\t\t\t\t\t.start(set) // 하위 실행 할 tasklet을 더 구성했다면 .next(new 새로운Tasklet())로 추가해주시면 됩니다.\t\t\t\t\t.build();}c. 완성된 Config현 예제는 Quartz를 추가 구성 할 때 그대로 쓸 예정입니다.@Configuration@RequiredArgsConstructorpublic class BatchConfig { private final JobBuilderFactory jobBuilderFactory; private final StepBuilderFactory stepBuilderFactory;\t\t// Step Configuration @Bean\t\t@JobScope public Step stepOne() { return stepBuilderFactory.get(\"stepOne\")\t\t\t\t\t\t\t\t.allowStartIfComplete(true) .tasklet(new TaskTasklet()) .build(); }\t\t// Job Configuration \t\t@Bean\t\tpublic Job setTestJob() throws Exception {\t\t\treturn jobBuilderFactory.get(\"testJob\")\t\t\t\t\t\t\t.incrementer(new RunIdIncrementer())\t\t\t\t\t\t\t.start(stepOne()) // 하위 실행 할 tasklet을 더 구성했다면 .next(new 새로운Tasklet())로 추가해주시면 됩니다.\t\t\t\t\t\t\t.build();\t\t}}4. 마치며스프링 배치의 간단한 설명과 구성에 대해서 알아보았습니다.처음 블로그를 쓰는 터라 부족함이 많지만 읽어주셔서 감사합니다.Spring Batch를 막연하게 코딩하여 쓰기만 했지만 블로깅을 작성하면서 자세히 알아볼 수 있는 시간이 되었습니다.더 자세히 알아보고 싶으시다면 아래 참고자료의 jojoldu님 가이드나 Spring Batch Documentation을 봐주시면 될 것 같습니다.다음 편에서 Quartz에 대해서 설명드리겠습니다.5. 참고자료Spring Batch - Reference Documentation마크다운 markdown 작성법jojoldu님의 Spring batch 가이드" }, { "title": "SOLID 정리 및 적용방법", "url": "/posts/solid/", "categories": "SDM, SOLID", "tags": "writing", "date": "2021-11-01 07:10:20 +0900", "snippet": "SOLIDSOLID?위키백과의 정의는 아래 내용입니다 SOLID란 로버트 마틴이 2000년대 초반에 명명한 객체 지향 프로그래밍 및 설계의 다섯 가지 기본 원칙을 마이클 페더스가 두문자어 기억술로 소개한 것이다. 프로그래머가 시간이 지나도 유지 보수와 확장이 쉬운 시스템을 만들고자 할 때 이 원칙들을 함께 적용할 수 있다. SOLID 원칙들은 소프트웨어 작업에서 프로그래머가 소스 코드가 읽기 쉽고 확장하기 쉽게 될 때까지 소프트웨어 소스 코드를 리팩터링하여 코드 냄새를 제거하기 위해 적용할 수 있는 지침이다. 이 원칙들은 애자일 소프트웨어 개발과 적응적 소프트웨어 개발의 전반적 전략의 일부다.5가지 원칙 Single Responsibility Principle(SRP) : 단일 책임 원칙 Open-Closed Principle(OCP) : 오픈 개방 원칙 Liskov Substitution Principle(LSP) : 리스코브 치환 원칙 Interface Segregation Principle(ISP) : 인터페이스 분리 원칙 Dependency Inversion Principle(DIP) : 의존성 역전의 원칙 5가지 원칙 정리 및 적용방법Single Responsibility Principle(SRP) 작성된 클래스는 하나의 기능만 가진다 클래스가 제공하는 모든 서비스 단 하나의 책임을 수행하는 데 집중되어야 한다 어떤 변화에도 클래스를 변경하는 이유는 하나뿐이어야 한다Open-Closed Principle(OCP) 소프트웨어 구성요소는 확장에는 열려있고 변경에는 닫혀있어야 한다 위의 내용은 변경을 위한 비용은 줄이고 확장을 위한 비용은 가능한 극대화해야 한다는 의미 요구사항 변경으로 기존 구성요소는 수정하지 않으면서 기존 구성요소를 확장하여 재사용할 수 있어야 한다Liskov Substitution Principle(LSP) 프로그램의 객체는 프로그램의 정확성을 깨드리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다 Interface Segregation Principle(ISP)Dependency Inversion Principle(DIP)" }, { "title": "Jenkins CentOS 설치", "url": "/posts/jenkins-linux-centos/", "categories": "", "tags": "", "date": "2021-10-21 19:39:00 +0900", "snippet": "Red Hat / CentOS젠킨스 설치## LTS installsudo wget -O /etc/yum.repos.d/jenkins.repo \\ https://pkg.jenkins.io/redhat-stable/jenkins.reposudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.keysudo yum upgrade# Add required dependencies for the jenkins packagesudo yum install java-11-openjdksudo yum install jenkinssudo systemctl daemon-reload젠킨스 시작sudo systemctl enable jenkinssudo systemctl start jenkinssudo systemctl status jenkins" }, { "title": "Jenkins Fedora 설치", "url": "/posts/jenkins-linux-fedora/", "categories": "", "tags": "", "date": "2021-10-21 19:36:00 +0900", "snippet": "Fedora자바 설치젠킨스 설치## LTS installsudo wget -O /etc/yum.repos.d/jenkins.repo \\ https://pkg.jenkins.io/redhat-stable/jenkins.reposudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.keysudo dnf upgrade# Add required dependencies for the jenkins packagesudo dnf install java-11-openjdksudo dnf install jenkinssudo systemctl daemon-reload젠킨스 시작sudo systemctl enable jenkinssudo systemctl start jenkinssudo systemctl status jenkins" }, { "title": "Jenkins Debian/Ubuntu 설치", "url": "/posts/jenkins-linux-debian/", "categories": "", "tags": "", "date": "2021-10-21 19:33:00 +0900", "snippet": "Debian/Ubuntu자바 설치$ sudo apt update$ sudo apt install openjdk-11-jre$ java -versionopenjdk version \"11.0.12\" 2021-07-20OpenJDK Runtime Environment (build 11.0.12+7-post-Debian-2)OpenJDK 64-Bit Server VM (build 11.0.12+7-post-Debian-2, mixed mode, sharing)젠킨스 설치## LTS installcurl -fsSL https://pkg.jenkins.io/debian-stable/jenkins.io.key | sudo tee \\ /usr/share/keyrings/jenkins-keyring.asc &gt; /dev/nullecho deb [signed-by=/usr/share/keyrings/jenkins-keyring.asc] \\ https://pkg.jenkins.io/debian-stable binary/ | sudo tee \\ /etc/apt/sources.list.d/jenkins.list &gt; /dev/nullsudo apt-get updatesudo apt-get install jenkins젠킨스 시작sudo systemctl enable jenkinssudo systemctl start jenkinssudo systemctl status jenkins" }, { "title": "Jenkins Linux 설치", "url": "/posts/jenkins-linux/", "categories": "", "tags": "", "date": "2021-10-21 19:30:00 +0900", "snippet": "제품별 설치Debian/UbuntuFedoraCentOS" }, { "title": "Jenkins 간단 설명 & 설치", "url": "/posts/jenkins/", "categories": "Install, Jenkins", "tags": "writing", "date": "2021-10-21 19:15:00 +0900", "snippet": "JenkinsJenkins란? Java로 빌드 된 오픈 소스 CI(Continuous Integration) 및 CD(Continuous Delivery) 도구 소프트웨어 구축, 테스트, 전달 또는 배포와 관련된 모든 종류의 작업을 자동화하는 데 사용할 수 있는 독립형 오픈 소스 자동화 서버 기본 시스템 패키지, Docker를 통해 설치하거나 JRE(Java Runtime Environment)가 설치된 모든 시스템에서 독립 실행형으로 실행할 수 있음설치 방법최소 사양 메모리 : 256 MB 디스크 공간 : 1 GB (10GB 추천)권장 사양 메모리 : 4 GB 이상 디스크 공간 : 50 GB 이상소프트웨어 요구사항 Java Web Browser운영체제 별 설치Linux" }, { "title": "GitLab 설치", "url": "/posts/gitlab-install/", "categories": "Install, GitLab", "tags": "writing", "date": "2021-10-20 14:15:00 +0900", "snippet": "GitLabLinux 설치# apt updatesudo apt updatesudo apt upgrade -y# dependency 설치sudo apt install -y ca-certificates curl openssh-server# gitlab ce repository addcurl -sS https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.deb.sh | sudo bash# apt update 및 gitlab installsudo apt updatesudo apt -y install gitlab-ce# gitlab settingssudo vi /etc/gitlab/gitlab.rb # external_url modify# settings 변경 시 아래 명령어를 통해 반영sudo gitlab-ctl reconfigure# service actionsudo gitlab-ctl statussudo gitlab-ctl stopsudo gitlab-ctl restart# 또는sudo gitlab-ctl restart logrotate" }, { "title": "PostgreSQL Mac 설치 및 실행", "url": "/posts/postgresql/", "categories": "Install, Postgres", "tags": "writing", "date": "2021-10-19 18:30:00 +0900", "snippet": "Postgres설치 및 실행Mac Install Homebrew 설치 후 brew install postgres 설치 완료 후, pg_ctl -D /usr/local/var/postgres start &amp;&amp; brew services start postgresql postgres -V : 버전 확인 psql postgres 가 잘 실행되는지 확인psql 단축 명령어 \\c : 접속한 DB Instance 변경 사용법 \\c [DB Name] [Connection User] \\list(or \\l), \\d[t | s | f | v | u] : 목록 조회용 명령어 \\list(or \\l) : 전체 Database Instance 목록 \\dt : 접속한 DB Instance의 Table 목록 \\ds : Sequence 목록 \\df : Function 목록 \\dv : View 목록 \\du : User 목록 \\d : 특정 테이블의 상세 정보를 출력 사용법 \\d [Table Name] \\g, \\s : Command 실행 History 조회 및 활용 \\g : 방금 전에 실행했던 명령어를 실행. (history 사용 가능할 경우 사용 필요 없음) \\s : 이전에 실행했던 명령어 전체 List 조회 \\h, \\? : 도움말 조회 \\h : SQL command 관련 도움말 \\? : psql command 관련 도움말 \\x, \\a, \\H : Query 결과 Display 설정 \\x : Column 들을 한줄로 조회하기 힘들 때, Column을 세로로 배치해서 Display하는 기능 on/off \\a : Column Align on/off. Default는 Align On 상태 \\H : Column 명과 결과 값을 HTML Table 형식으로 Display하는 기능 on/off. \\timing : Query 실행 시간 표시 \\i : 외부 파일을 통한 Query 실행 \\i [File Name] \\e, \\ef : 외부 Editor 사용 \\e : \\i가 이미 만들어진 File 안에 있는 Query를 수행하는데 비해, \\e는 외부 편집기를 통해 Query를 작성해서 실행할 때 사용. 사용법은 \\e [File Name] \\ef : \\e와 유사하나 FUNCTION 편집할 때 사용한다는 측면에서 상이. 사용법은 \\ef [Function Name] ! : Shell Command 실행사용법 ! [Shell Command]ex) ! clear : 화면 clear! pwd : 현재 경로 확인! ls : 현재 경로의 파일 확인! cd [Path] : [Path]로 경로 이동 \\q : psql 종료" }, { "title": "jekyll theme 적용 + git blog 적용하는 법", "url": "/posts/jekyll-theme/", "categories": "Blogging, GitBlog", "tags": "writing", "date": "2021-09-18 10:38:00 +0900", "snippet": "Jekyll theme에 적용하는 방법안녕하세요 Bisso입니다. 오늘은 전에 적용하기로 했던 jekyll theme 적용해보려고 해요. jekyll Theme 사이트 http://jekyllthemes.org/ https://jekyll-themes.com/free/ http://themes.jekyllrc.org/ https://jekyllthemes.io/free위의 사이트를 참고하시면 좋아요" }, { "title": "github blog 사용법 + Jekyll 적용", "url": "/posts/git-blog-linux/", "categories": "Blogging, GitBlog", "tags": "writing", "date": "2021-09-12 10:46:00 +0900", "snippet": "Github 블로그 만드는 방법 Repository 생성 Repository 이름 -&gt; [username].github.io 설정 ( username : github username ) git clone git clone (repository_url) cd [username].github.io touch index.html ( OS가 windows인 경우는 파일 생성해주시면 됩니다 ) index.html 파일 수정 아래 이미지 처럼 수정 git push 변경된 내용 들을 repository에 push git add .git commit -m \"Initial Commit\"git push origin [브랜치이름] git blog 확인 [username].github.io 접속 화면 확인 아무것도 없는 화면이지만 Jekyll 테마를 적용해서 더 이쁘게 만들 수 있어요 Jekyll 테마를 적용해볼게요 Jekyll 테마 적용 Jekyll installgem install jekyll bundler실행하여 Jekyll 설치해주세요Mac에서 실행 시 아래 에러 발생 시 system Ruby를 쓰고 있어 권한이 없어 설치 오류 발생. Ruby를 설치해주어야 합니다.$ gem install bundlerERROR: While executing gem ... (Gem::FilePermissionError) You don't have write permissions for the /Library/Ruby/Gems/2.6.0 directory.오류 조치 방법 rbenv 설치brew install rbenv ruby-buildrbenv versions -&gt; 잘 설치 되어있는지 확인* system (set by /Users/jk-pc/.rbenv/version) 2.7.4system ruby로 세팅 되어 있는 것을 확인하실 수 있습니다. 설치 가능 버전 확인rbenv install -l2.6.82.7.43.0.2jruby-9.2.19.0mruby-3.0.0rbx-5.0truffleruby-21.2.0.1truffleruby+graalvm-21.2.0저는 3.0.2 버전을 설치했다가 제가 사용하고 싶은 테마가 3.0.0 이상을 지원하지 않아 2.7.4 버전을 설치했습니다. ^^ Ruby 설치 및 버전 확인rbenv install [설치할 버전]rbenv versions* system (set by /Users/jk-pc/.rbenv/version) 2.7.4 global 버전 변경rbenv global 2.7.4 system* 2.7.4 (set by /Users/jk-pc/.rbenv/version)system ruby 말고 저의 경우엔 2.7.4 를 set 하고 있습니다.마지막으로 rbenv path 추가하기 위해 shell 설정 파일 변경을 해줘야 합니다.vi ~/.zshrc 또는 (자신의 쉘 파일을 열어주세요)아래 설정 추가[[ -d ~/.rbenv ]] &amp;&amp; \\ export PATH=${HOME}/.rbenv/bin:${PATH} &amp;&amp; \\ eval \"$(rbenv init -)\" 적용source ~/.zshrc 또는 (자신이 적용한 쉘)gem install jekyll bundler하면 jekyll이 성공적으로 설치되는 것을 보실 수 있을겁니다 ^^ 테스트 화면으로 썼던 index.html을 제거해주신 후, [username].github.io 위치에서 아래 커맨드를 입력해주세요.jekyll new .jekyll이 생성되었어요. 그럼 이제 install을 해볼까요? 아래 커맨드를 입력해주면 jekyll을 실행할 수 있어요bundle installbundle exec jekyll serve실행 후 화면에 표기된 127.0.0.1:4000 으로 접속하면 아래 이미지처럼 생성된 git blog를 보실 수 있습니다.이상 git blog 생성까지 해보았습니다. 다음 편에서는 jekyll theme를 적용하는 포스팅을 해볼게요~ 감사합니다." } ]
